

\documentclass[11pt]{article}
\usepackage{algpseudocode}
\usepackage[latin1]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{graphicx}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{13.6pt}
\newcommand\question[2]{\vspace{.25in}\hrule\textbf{#2}\vspace{.5em}\hrule\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\newcommand\algorithm{\vspace{.10in}\textbf{Algorithm: }}
\newcommand\correctness{\vspace{.10in}\textbf{Correctness: }}
\newcommand\runtime{\vspace{.10in}\textbf{Running time: }}
\pagestyle{fancyplain}
\lhead{\textbf{Pontificia Universidad Católica de Chile \\ Departamento de Ciencia de la Computación  \\ \hrule} }


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}\raggedright
\newcommand\NAME{Fernando Suárez}  \newcommand\HWNUM{10}   
\newcommand{\Tau}{\mathrm{T}}         
\title{\textbf{\LARGE Ayudantía 10\\ \large Análisis de Algoritmos}}
\date{27 de Junio, 2014}
\author{Fernando Suárez}
\maketitle

%\includegraphics[width=2.5cm]{chile} \textbf{\large VAMOS CHILE QUE MAÑANA HACEMOS HISTORIA !!!!}
\question{1}{Problema 1} 
Dado un arreglo $A[1...n]$, un \emph{descenso} es un par de elementos adyacentes en el arreglo, $A[i]$ y A[i+1], tales que $A[i]>A[i+1]$.
\\
Considere el siguiente algoritmo: 
\\
\begin{algorithmic}[1]
 \State $i\gets 1$
 \State $s\gets 0$
 \While{$i< n$}
 \If {$A[i]>A[i+1]$}
  \State $s\gets s+1$
 \EndIf
  \State $i\gets i+1$
 \EndWhile
 \\ 
\Return {$s$}
\end{algorithmic}
Conteste las siguientes preguntas: \\
a) ¿Qué hace el algoritmo ?\\
b) Enuncie un invariante del loop adecuado para demostrar que el algoritmo hace lo que propuso en (a)\\
c) Demuestre que, efectivamente, la expresión dada en la parte (b) es un invariante para el loop dado.\\
d) Demuestre la corrección parcial del algoritmo(o sea, si éste termina, entonces el valor retornado es el que propuso en la parte (a))\\
e) Demuestre que el algoritmo efectivamente termina. 
\newpage

 \textbf{\large Solución:}\\
 a) El algoritmo que retorna la variable $s$, la cual almacena el número de descensos que hay en el arreglo $A$.\\
 \par
\bigskip
 b) $P(k): 0\leq k<n\rightarrow (i_k=k+1\wedge s_k=|\{j \in  \mathbb{N}:1\leq j \leq k \wedge A[j]>A[j+1]\}|)$\\
 \par
\bigskip
 c) Por inducción sobre $k$:\\
 Si $k=0$, justo antes de ejecutar el loop por primera vez, se tiene $i_0=1\wedge s_0=0\wedge |\{j \in  \mathbb{N}:1\leq j \leq k \wedge A[j]>A[j+1]\}|=0)$, como se desea. Sea $k\geq 0$ y supongamos (HI) que $P(k)$ se cumple. Debemos demostrar que $P(k+1)$ se cumple.\\
 Si $k\geq n-1$, $k+1\geq n$ y $P(k+1)$ es trivialmente verdadero. Si $k<n-1$, $k+1<n$ y entonces el loop se ejecuta por la iteración $k+1$.\\
 Tras $k+1$ iteraciones, $i_{k+1}=i_k+1=k+2$, y\\
 $$
s_{k+1} =
\begin{cases}
s_k, & \text{si }A[i_k]\leq A[i_{k+1}]= A[k+2]\text{, } \\
s_k+1, & \text{si }A[i_k]>A[i_{k+1}]=A[k+2]
\end{cases}
$$\\
Por otra parte, \\
$|\{j \in  \mathbb{N}:1\leq j \leq k+1 \wedge A[j]>A[j+1]\}|=$\\
 $$
\begin{cases}
|\{j \in  \mathbb{N}:1\leq j \leq k \wedge A[j]>A[j+1]\}|, & \text{si }A[i_k]\leq A[i_{k+1}]= A[k+2]\text{, } \\
|\{j \in  \mathbb{N}:1\leq j \leq k \wedge A[j]>A[j+1]\}|+1, & \text{si }A[i_k]>A[i_{k+1}]=A[k+2]
\end{cases}
$$\\
Por hipótesis de inducción, $s_k=|\{j \in  \mathbb{N}:1\leq j \leq k \wedge A[j]>A[j+1]\}|$, por lo que las cantidades correspondientes a $|\{j \in  \mathbb{N}:1\leq j \leq k+1 \wedge A[j]>A[j+1]\}|$ y a $s_{k+1}$ son iguales.\\
\par
\bigskip
d) Supongamos que el algoritmo termina tras $k$ iteraciones. Al terminar, debe tenerse $i_k=n$, o sea, $k+1=n$, o sea, $k=n-1$. Por lo tanto, debe cumplirse $P(n-1)$, por lo que se tiene que $s_{n-1}=|\{j \in  \mathbb{N}:1\leq j \leq n-1 \wedge A[j]>A[j+1]\}|$, que es precisamente lo que se debe probar.\\
\par
\bigskip
e) Notamos que la expresión $n-i$ es entera (obvio), estrictamente decreciente en el loop (ya que de un paso al siguiente su valor baja en 1, ya que $i$ aumenta) y acotada inferiormente por 1 dentro del loop. Así, el loop es ejecutado una cantidad finita de veces.\\
\newpage

\question{2}{Problema 2}
a) Demuestre que, dado $n, k\in \mathbb{N}$, se tiene $\sum\limits_{i=1}^ n i^k\in \Theta(n^{k+1})$.\\
b) Demuestre que, dado $n\in\mathbb{N}$, se tiene $\sum\limits_{i=1}^n \log_2 i\in\Theta(n\log_2 n)$
\par
\bigskip
 \textbf{\large Solución:}\\
a) Claramente $f(n)=\sum\limits_{i=1}^ n i^k\leq\sum\limits_{i=1}^ n n^k=n^{k+1}$, por lo que $f(n)\leq1\cdot n^{k+1}$ para todo $n\geq1$.\\ Así, $f(n)\in O(n^{k+1})$.\\Por otra parte, 
\begin{equation}
f(n)=\sum\limits_{i=1}^ n i^k\geq \int\limits_{i=0}^ n x^k \, \mathrm{d}x=\frac{n^{k+1}}{k+1}=\frac{1}{k+1}\cdot n^{k+1}
\end{equation}
Como $\frac{1}{k+1}$ es constante, se tiene $f(n)\in \Omega(n^{k+1})$.\\
Como $f(n)\in O(n^{k+1})\cap\Omega(n^{k+1})$, tenemos $f(n)\in\Theta(n^{k+1})$.\\

 \textbf{\large Nota:}\\
 Otra forma de acotar inferiormente $f(n)$ es, en principio, pensar en 
 \begin{equation}
f(n)=\sum\limits_{i=1}^ n i^k\geq \sum\limits_{i=\frac{n}{2}}^ n i^k\geq \sum\limits_{i=\frac{n}{2}}^ n (\frac{n}{2})^k=\frac{n}{2}\cdot(\frac{n}{2})^k=\frac{1}{2^{k+1}}\cdot n^{k+1}.
\end{equation}
Esta idea tiene el problema de que $n/2$ no es entero, y al tratar de reemplazarlo por $\floor{n/2}$o $\ceil{n/2}$ se pierde un factor o éstos no son lo suficientemente grandes.\\Para arreglar este problema, puede ocuparse:
 \begin{equation}
f(n)=\sum\limits_{i=1}^ n i^k\geq \sum\limits_{i=\floor{\frac{2n}{3}}}^ n i^k\geq \sum\limits_{i=\floor{\frac{2n}{3}}}^ n (\frac{n}{3})^k\geq\frac{n}{3}\cdot(\frac{n}{3})^k=\frac{1}{3^{k+1}}\cdot n^{k+1}.
\end{equation}
\par
\bigskip
b) Por un lado, acotar a $\sum\limits_{i=1}^n \log_2 i$ es sencillo, ya que
\begin{equation}
\sum\limits_{i=1}^n \log_2 i\leq\sum\limits_{i=1}^n \log_2 n=n\log_2 n,
\end{equation}
por lo que $\sum\limits_{i=1}^n \log_2 i\leq1\cdot n\log_2 n$ para todo $n\geq1$.\\
Luego, sólo falta acotar a $\sum\limits_{i=1}^n \log_2 i$ por abajo:
\begin{gather}
\sum\limits_{i=1}^n \log_2 i\geq\sum\limits_{i=\floor{n/2}+1}^n \log_2 i\geq\sum\limits_{i=\floor{n/2}+1}^n \log_2 (\floor{n/2}+1)\\
\geq\sum\limits_{i=\floor{n/2}+1}^n \log_2 (n/2)=(n-\floor{n/2})\log_2 (n/2)=\ceil{n/2}\log_2 (n/2)\\
\geq\frac{n}{2}\cdot\log_2 (n/2)=\frac{n}{2}\cdot(\log_2 (n)-1)
\end{gather}
Pero, para $n\geq4$, $\log_2 n\geq2$, por lo que $\log_2 n -1\geq\frac{1}{2}\cdot\log_2 n$.\\
Así, si $n\geq4$, tenemos
\begin{gather}
\sum\limits_{i=1}^n \log_2 i\geq\frac{n}{2}\cdot\frac{1}{2}\cdot\log_2 n=\frac{1}{4}\cdot n\log_2 n\\
\text{Así, hemos demostrado que si }n\geq4, entonces\\
\frac{1}{4}\cdot n\log_2 n\leq\sum\limits_{i=1}^n \log_2 i\leq1\cdot n\log_2 n\\
\text{o sea, hemos probado que }\\
\sum\limits_{i=1}^n \log_2 i\in\Theta(n\log_2 n).
\end{gather}

\question{3}{Problema 3}
Considere el siguiente algoritmo:
\par
\bigskip
\begin{algorithmic}[1]
%$MergeSort(A[1..n])$
\Function{MergeSort}{A,f,l} 
 \If {$(n>1)$}
 \State $m\gets \floor{\frac{f+l}{2}} $\\
 \Call{MergeSort}{A,f,m}\\
 \Call{MergeSort}{A,m+1,l}\\ 
 \Call{Merge}{A[f...m],A[m+1...l],A[f...l]}
  \EndIf
\EndFunction
\end{algorithmic}
a) Encuentre una función $\Tau(n)$ para la cantidad de comparaciones que realiza el algoritmo $MergeSort$ en el peor caso, en función del tamaño del arreglo.\\
b) Demuestre que $\Tau(n)$ es no-decreciente para todo $n\in  \mathbb{Z}^+$.\\
c) Calcule la complejidad de $MergeSort$. \emph{Hint:} Calcule la compejidad para todo $n\in  POTENCIA_2$.
\par
\bigskip
 \textbf{\large Solución:}\\
a) $$
\Tau(n) =
\begin{cases}
\Theta(1) & \text{si }n=1 \\
\Tau(\ceil{n/2})+\Tau(\floor{n/2})+\Theta(n) & \text{eoc}
\end{cases}
$$\\
 \par
\bigskip
b) Sea 
 \begin{equation}
P(n): \Tau(n)\leq\Tau(n+1)
\end{equation}
Demostraremos que, para todo $n\geq1$, se cumple $P(n)$. Para esto usamos inducción fuerte. Supongamos que para todo $k\in\mathbb{N},1\leq k<n$, se cumple $P(k)$. Debemos probar que $P(n)$ se cumple. Hay dos casos:\\
\begin{itemize}
  \item n=1.\\
  En este caso, como
   \begin{equation}
\Tau(2)=\Tau(\ceil{\frac{2}{2}})+\Tau(\floor{\frac{2}{2}})+2=1+1+2=4\geq1=\Tau(1)
\end{equation}
  \item $n>1$.\\
  Como en este caso $n>\ceil{\frac{n}{2}}\geq\floor{\frac{n}{2}}$, podemos aplicar la H.I. a $\ceil{\frac{n}{2}}$ y $\geq\floor{\frac{n}{2}}$. Así, 
   \begin{equation}
\Tau(n+1)-\Tau(n)=\Tau(\ceil{\frac{n+1}{2}})+\Tau(\floor{\frac{n+1}{2}})+n+1-\Tau(\ceil{\frac{n}{2}})-\Tau(\floor{\frac{n}{2}})-n
\end{equation}
   \begin{equation}
\Tau(n+1)-\Tau(n)=\left(\Tau(\ceil{\frac{n+1}{2}})-\Tau(\ceil{\frac{n}{2}})\right)+\left(\Tau(\floor{\frac{n+1}{2}})-\Tau(\floor{\frac{n}{2}})\right)+1
\end{equation}
Por H.I. los últimos dos paréntesis deben ser mayores o iguales a $0$. Luego, se cumple $P(n)$.
\end{itemize}
 \par
\bigskip
c) Dado que podemos asumir que el tamaño del arreglo pertenecerá a $POTENCIA_2$, las funciones $techo$ y $piso$ se simplifican. Nuestra recurrencia simplificada ahora se ve de la siguiente manera:\\
$$
\Tau(n) =
\begin{cases}
1 & \text{si }n=1 \\
2\Tau(n/2)+n& \text{eoc}
\end{cases}
$$\\
Para encontrar una solución a la recurrencia debemos ver que pasa en cada iteración de esta, si usamos el reemplazo $n=2^k$ :
\begin{equation}
\begin{split}
\Tau(n)=2\Tau(n/2)+n\\
\Tau(2^k)=2\Tau(2^{k-1})+2^k\\
\Tau(2^k)=2(2\Tau(2^{k-2})+2^{k-1})+2^k=4\Tau(2^{k-2})+2\cdot2^k\\
\Tau(2^k)=8\Tau(2^{k-3})+3\cdot2^k\\
.\\
.\\
.\\
\Tau(2^k)=2^i\cdot\Tau(2^{k-i})+i\cdot2^k\\
\end{split}
\end{equation}
Es posible ver que en la iteración $i$ la ecuación de recurrencia será $\Tau(2^k)=2^i\cdot\Tau(2^{k-i})+i\cdot2^k$. Sin embargo, debemos demostrar esto por inducción: 
\begin{gather}
 \text{ \textbf{CB:} }\Tau(2^k)=2^{1}\Tau(2^{k-1})+1\cdot2^k\\
 \text{ \textbf{HI:} }\Tau(2^k)=2^i\Tau(2^{k-i})+i\cdot2^k\\
  \text{ \textbf{PI:} }\Tau(2^k)=2^i(2\Tau(2^{k-i-1})+2^{k-i})+i\cdot2^k=2^{i+1}\Tau(2^{k-(i+1)})+(i+1)\cdot2^k\\
\end{gather}
Vemos que nuestra propuesta era válida. Además, es claro que en la iteración k podemos reemplazar el termino recursivo por el caso base:\\
\begin{equation}
\begin{split}
\Tau(2^k)=2^k\cdot\Tau(1)+k\cdot2^k\\
\Tau(2^k)=2^k+k\cdot2^k\\
\end{split}
\end{equation}
Reemplazando $k=\log_2 n$
\begin{equation}
\begin{split}
\Tau(n)=n+n\log_2 n\\
\end{split}
\end{equation}
Luego, $\Tau\in\Theta(n\log_2 (n))$.

\question{4}{Problema 4}

a) Demuestre que el problema $3-SAT$ es $NP$-completo\\
b) Demuestre que el problema $CLIQUE$ es $NP$-completo.\\
\par
\bigskip
 \textbf{\large Solución:}\\
 \par
\bigskip
a) Primero, notemos que el problema $3-SAT\in NP$. Esto ya que dada una fórmula $\psi$  en FNC de $m$ cláusulas y $n$ variables, es posible chequear si una valuación la satisface en tiempo polinomial($\leq n\cdot m$ en el peor caso).\\
Luego, dado que sabemos que $SAT$ es $NP$-completo, nos basta con encontrar una función entre $SAT$ y $3-SAT$ que sea ejecutable en tiempo polinomial.\\
Dada una instancia de $SAT$ con un conjunto $C=\{c_1,c_2,...,c_m\}$ de cláusulas sobre las variables $U=\{u_1,u_2,...,u_n\}$. Nos proponemos construir un conjunto $C'$ con cláusula sobre las sobre las variables $U'$, que consisten en las variables originales mas un conjunto de variables auxiliares. Estas nuevas cláusulas se construirán de la siguiente manera:\\
Se debe reemplazar cada $c_i\in C$ por un conjunto de cláusulas de 3 literales sobre las variables que aparecen en $c_i$ mas algunas variables auxiliares. El procedimiento exacto dependerá del número de literales en $c_i$. Sea $c_i\in C$ dado por $\{z_1,z_2,...,z_k\}$ donde $z_j$ es un literal sobre $U$. Tenemos los siguientes casos:
\begin{itemize}
  \item $k=1$.\\
  Tomemos $c_i=\{z_1\}$. Usaremos dos variables adicionales $\{y_{i,1},y_{i,2}\}$. Luego formamos el conjunto $C_i'=\{\{z_1,y_{i,1},y_{i,2}\},\{z_1,y_{i,1},\neg y_{i,2}\},\{z_1,\neg y_{i,1},\neg y_{i,2}\}\}$.
    \item k=2.\\
      Tomemos $c_i=\{z_1,z_2\}$. Usaremos una variable adicional $\{y_{i,1}\}$. Luego formamos el conjunto $C_i'=\{\{z_1,z_2,y_{i,1}\},\{z_1,z_2,\neg y_{i,1}\}\}$.
\item $k=3$.\\
      Tomemos $c_i=\{z_1,z_2,z_3\}$. No usaremos variables adicionales. Luego $C_i'=c_i$.
\item $k>3$.\\
      Tomemos $c_i=\{z_1,z_2,...,z_k\}$. Usaremos una variables adicionales $\{y_{i,1},y_{i,2},...,y_{i,k-3}\}$. Luego formamos el conjunto:\\
      $C_i'=\{\{z_1,z_2,y_{i,1}\},\{\neg y_{i,1},z_3, y_{i,2}\},\{\neg y_{i,2},z_4,y_{i,3}\},\{\neg y_{i,3},z_5,\neg y_{i,4}\},..,\{\neg y_{i,k-3},z_{k-1},z_k\}\}$.
  \end{itemize}
  Es sencillo darse cuenta que la cláusula original es satisfecha si y sólo si este nuevo conjunto es satisfecho. Nuevamente, estas transformaciones están acotadas por un polinomio en el largo de la cláusula($nm$).\\
 \newpage
b) Primero, es fácil ver que $CLIQUE$ esta en $NP$. Esto ya que dada una instancia $<G,k>$ y un $k$-clique, podemos verificar en $O(n^2)$ que existe un $k$-clique en $G$.\\
Ahora, queremos encontrar una reducción de $3-SAT$ a $CLIQUE$. Sea $\psi$ una fórmula booleana en $FNC$. Por cada literal en $\psi$ vamos a agregar un vértice en nuestro grafo.\\
Sea $k$ el número de cláusulas en $\psi$. Vamos a conectar vada vértice a todos los vértices restantes que sean lógicamente compatibles EXCEPTO por los que están en la misma cláusula. Ahora debemos demostrar que $G$ tiene un subgrafo completo de tamaño $k$ ssi $\psi$ es satisfactible.\\
$(\Rightarrow)$. Como todos los miembros del subgrafo pertenecen a cláusulas distintas, cualquier valuación $\sigma$ que hace verdadero a todos literales en el subgrafo hace verdadera a la fórmula. (recordemos que dos literales complementarios no pueden estar en un subgrafo completo)\\
$(\Leftarrow)$. Si la fórmula $\psi$ es satisfecha, debe existir una valuación $\sigma$ que haga verdaderos a al menos un literal en cada cláusula. Sean $l_1\in C_1, l_2\in C_2,..., l_k\in C_k$ estos literales. Notemos que no es posible que existan dos literales complementarios $l_i$ y $l_j (1\leq i<j\leq k)$. Necesariamente, entonces, podemos construir arcos entre cada para de nodos en donde aparecen dichos literales siguiendo las reglas de construcción del grafo.
\end{document}

